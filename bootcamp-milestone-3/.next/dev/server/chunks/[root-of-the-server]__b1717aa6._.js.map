{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/kylelin/bootcamp-project-2025/bootcamp-milestone-3/app/database/db.ts"],"sourcesContent":["// db.ts\nimport mongoose from \"mongoose\";\n\nconst url: string = process.env.MONGO_URI as string;\nlet connection: typeof mongoose;\n\n/**\n * Makes a connection to a MongoDB database. If a connection already exists, does nothing\n * Call this function at the start of api routes and data fetches\n * @returns {Promise<typeof mongoose>}\n */\nconst connectDB = async () => {\n  if (!connection) {\n    connection = await mongoose.connect(url);\n    return connection;\n  }\n};\n\nexport default connectDB;"],"names":[],"mappings":"AAAA,QAAQ;;;;;AACR;;AAEA,MAAM,MAAc,QAAQ,GAAG,CAAC,SAAS;AACzC,IAAI;AAEJ;;;;CAIC,GACD,MAAM,YAAY;IAChB,IAAI,CAAC,YAAY;QACf,aAAa,MAAM,oHAAQ,CAAC,OAAO,CAAC;QACpC,OAAO;IACT;AACF;uCAEe","debugId":null}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/kylelin/bootcamp-project-2025/bootcamp-milestone-3/app/database/blogSchema.ts"],"sourcesContent":["import mongoose, { Schema } from \"mongoose\";\n\n// typescript type (can also be an interface)\ntype Blog = {\n\ttitle: string;\n    date: string;\n    description: string;\n    image: string;\n    imageAlt: string;\n    slug: string;\n};\n\n\n// mongoose schema\nconst blogSchema = new Schema<Blog>({\n    title: { type: String, required: true },\n    date: { type: String, required: true },\n\t// date: { type: Date, required: false, default: new Date()},\n    description: { type: String, required: true },\n    image: { type: String, required: true },\n    imageAlt: { type: String, required: true },\n    slug: { type: String, required: true },\n})\n\n// defining the collection and model\nconst Blog = mongoose.models['blogs'] ||\n    mongoose.model('blogs', blogSchema);\n\nexport default Blog;"],"names":[],"mappings":";;;;AAAA;;AAaA,kBAAkB;AAClB,MAAM,aAAa,IAAI,mHAAM,CAAO;IAChC,OAAO;QAAE,MAAM;QAAQ,UAAU;IAAK;IACtC,MAAM;QAAE,MAAM;QAAQ,UAAU;IAAK;IACxC,6DAA6D;IAC1D,aAAa;QAAE,MAAM;QAAQ,UAAU;IAAK;IAC5C,OAAO;QAAE,MAAM;QAAQ,UAAU;IAAK;IACtC,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAK;IACzC,MAAM;QAAE,MAAM;QAAQ,UAAU;IAAK;AACzC;AAEA,oCAAoC;AACpC,MAAM,OAAO,oHAAQ,CAAC,MAAM,CAAC,QAAQ,IACjC,oHAAQ,CAAC,KAAK,CAAC,SAAS;uCAEb","debugId":null}},
    {"offset": {"line": 117, "column": 0}, "map": {"version":3,"sources":["file:///Users/kylelin/bootcamp-project-2025/bootcamp-milestone-3/app/api/blog/%5Bslug%5D/route.ts"],"sourcesContent":["\nimport { NextRequest, NextResponse } from 'next/server'\nimport connectDB from \"@/app/database/db\"\nimport blogSchema from \"@/app/database/blogSchema\"\n\n/* IParams is a TypeScript type definition that describes the structure of the second\n   argument that Next.js passes to our API route handler.\n\n   Without IParams:\n   - TypeScript wouldn't know what properties the second argument contains\n   - We'd lose autocomplete and type checking\n   - Typos like { slug } vs { slg } wouldn't be caught until runtime\n\n   With IParams:\n   - TypeScript knows the second argument has a \"params\" object\n   - TypeScript knows \"params\" contains a \"slug\" property that's a string\n   - We get autocomplete when typing { params } and { slug }\n   - TypeScript catches errors if we try to access non-existent properties\n\n   Note: IParams doesn't control what Next.js creates - it just tells TypeScript\n   what to expect. The actual object structure is determined by our file path:\n   /api/blog/[slug]/route.ts creates { params: { slug: \"actual-slug-value\" } }\n*/\ntype IParams = {\n\t\tparams: {\n\t\t\tslug: string\n\t\t}\n}\n\n/*\n\tThe function below and the functions you create inside route.ts files are called\n\t\"API route handlers\"\n\n\tNext.js automatically passes two arguments to API route handlers:\n\t\t1. First argument: NextRequest - The incoming HTTP request object\n\t\t2. Second argument: NextJS Object - Contains route information and other metadata\n\t\t\t\tThere is ALWAYS a \"params\" object here but the object within is based on our\n\t\t\t\tapi path naming which in this case is \"slug\"\n\tWe need to include req, even though we don't use it here, so that we can access\n\tthe second argument\n*/\nexport async function GET(req: NextRequest, { params }: IParams) {\n\t\t// If { params } looks confusing, check the note below this code block\n\n    await connectDB() // function from db.ts before\n\t\tconst { slug } = params // another destructure\n\n\t   try {\n\t        const blog = await blogSchema.findOne({ slug }).orFail()\n\t        return NextResponse.json(blog)\n\t    } catch (err) {\n\t        return NextResponse.json('Blog not found.', { status: 404 })\n\t    }\n}\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAsCO,eAAe,IAAI,GAAgB,EAAE,EAAE,MAAM,EAAW;IAC7D,sEAAsE;IAEpE,MAAM,IAAA,+LAAS,KAAG,6BAA6B;IACjD,MAAM,EAAE,IAAI,EAAE,GAAG,OAAO,sBAAsB;;IAE5C,IAAI;QACC,MAAM,OAAO,MAAM,uMAAU,CAAC,OAAO,CAAC;YAAE;QAAK,GAAG,MAAM;QACtD,OAAO,6MAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,KAAK;QACV,OAAO,6MAAY,CAAC,IAAI,CAAC,mBAAmB;YAAE,QAAQ;QAAI;IAC9D;AACL","debugId":null}}]
}